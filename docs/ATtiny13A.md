# ATtiny13A

Notes as to developing C code on the Microchip ATtiny13A. Much of this content was generated by Claude Opus 4 on June 3, 2025.

## Datasheets and Information

* [Microchip ATtiny13A](https://www.microchip.com/en-us/product/attiny13a)
* [ATtiny13A-Data-Sheet-DS40002307A](https://ww1.microchip.com/downloads/en/DeviceDoc/ATtiny13A-Data-Sheet-DS40002307A.pdf)
* [Bloom Target Information](https://bloom.oscillate.io/docs/target/attiny13a)
* [Efficient C Coding for 8-bit AVR Processors](https://www.microchip.com/en-us/application-notes/an1497)

## Links to Projects
* [Enable PWM on an ATtiny by programming its registers](https://www.hackster.io/bearislive/enable-pwm-on-an-attiny-by-programming-its-registers-565948)
* [Programming an ATtiny13A in Assembly](https://www.hackster.io/gatoninja236/programming-an-attiny13a-in-assembly-30a529)
* [Programming the ATTINY13 \(Microcore\)](https://bryceautomation.com/index.php/2021/08/16/programming-the-attiny13-microcore/)
* [Various programs for attiny13a](https://github.com/hack-tramp/attiny13a)
* [Programming ATtiny13 with Arduino Uno to control a Servo Motor](https://circuitdigest.com/microcontroller-projects/programming-attiny13-with-arduino-uno-control-a-servo-motor)
* [ATtiny13A programming - Page 1](https://www.eevblog.com/forum/microcontrollers/attiny13a-programing/)
* [Stack Exchange: ATTiny13 -- avr-gcc Hello World uses over 100 bytes?](https://electronics.stackexchange.com/questions/2377/attiny13-avr-gcc-hello-world-uses-over-100-bytes)
* [Smart LED Prototypes](https://todbot.com/blog/2007/03/25/smart-led-prototypes/)
* [Stack Exchange: Missing crt* file](https://stackoverflow.com/questions/20356871/avr-gcc-destructive-optimizations)
* [benwattsjones/AVR-Microcontroller-Tutorial: A series of lessons on programming AVR MCUs using GCC-AVR on linux](https://github.com/benwattsjones/AVR-Microcontroller-Tutorial)
* [ATtiny13A Examples](https://github.com/casperbang/avr-attiny-tutorial?tab=readme-ov-file)
## **Basic Circuit Requirements**

The **ATtiny13 is a low-power CMOS 8-bit microcontroller** based on the AVR enhanced RISC architecture. To make it functional:

### **Power Supply Components**
- **VCC**: Connect to pin 8 (supply voltage: 2.7V to 5.5V)
- **GND**: Connect to pin 4
- **Decoupling capacitor**: 100nF ceramic capacitor between VCC and GND, placed as close to the chip as possible

### **Programming Interface**
For In-System Programming (ISP), connect:
- **MISO** (PB0) - Pin 5
- **MOSI** (PB1) - Pin 6  
- **SCK** (PB2) - Pin 7
- **RESET** - Pin 1
- **VCC** and **GND** from programmer

### **Reset Circuit**
- **10kΩ pull-up resistor** from RESET (pin 1) to VCC
- Optional: Small capacitor (100nF) from RESET to GND for noise immunity
- Optional: Reset button between RESET and GND

### **Basic Schematic Layout**

```
                    ATtiny13
                   ┌─────────┐
    RESET/PB5 ──1─┤         ├─8── VCC
          PB3 ──2─┤         ├─7── PB2/SCK
          PB4 ──3─┤         ├─6── PB1/MOSI
          GND ──4─┤         ├─5── PB0/MISO
                   └─────────┘
```

### **Minimal Working Circuit**
1. Connect **VCC** (pin 8) to your power supply (2.7-5.5V)
2. Connect **GND** (pin 4) to ground
3. Add **100nF decoupling capacitor** between VCC and GND
4. Add **10kΩ resistor** between RESET (pin 1) and VCC
5. Connect ISP header for programming

The **ATtiny13 contains 1KB of Flash memory** for program storage and features **6 I/O pins** that can be used for various functions. This makes it ideal for simple embedded applications where space and power consumption are critical factors.

For more complex applications, you might want to add:
- External crystal oscillator (though the ATtiny13 has an internal 9.6MHz oscillator)
- Additional filtering capacitors
- Protection diodes on I/O pins
- LED indicators for debugging

## Adding capability for debugging
To use **DebugWire** debugging with the ATtiny13, you'll need to make specific hardware and software configurations. Here's what you need to do:

## **Hardware Requirements for DebugWire**

### **Modified Reset Pin Configuration**
- **Remove the 10kΩ pull-up resistor** from the RESET pin (pin 1)
- The RESET pin becomes a **bidirectional communication line** when DebugWire is enabled
- Keep the reset line as short as possible to minimize noise

### **Simplified Connection**
When using DebugWire, you only need:
- **RESET/dW** (pin 1) - Connected to debugger
- **VCC** (pin 8) - Power supply
- **GND** (pin 4) - Ground
- **100nF decoupling capacitor** between VCC and GND

### **Important Considerations**

1. **Fuse Configuration**
   - You must **enable the DWEN (DebugWire Enable) fuse bit**
   - Once enabled, the RESET pin loses its reset functionality and becomes a DebugWire interface
   - ISP programming is disabled when DebugWire is active

2. **Debugger Requirements**
   - Use a compatible debugger like **Atmel-ICE**, **JTAGICE mkII**, or **AVR Dragon**
   - The debugger must support DebugWire protocol

3. **Power Cycling**
   - After enabling DebugWire, you need to **power cycle** the target device
   - The debugger will then communicate through the single-wire interface

### **To Disable DebugWire**
If you need to return to normal ISP programming:
1. Use the debugger to **disable DebugWire** through the debugging software
2. Or perform a **high-voltage programming** sequence to clear the DWEN fuse
3. This restores the RESET pin functionality

### **Circuit Modification Summary**
```
   For DebugWire Mode:
   
   RESET/dW (pin 1) ──────── To Debugger (no pull-up)
   VCC (pin 8) ────────────── Power Supply
   GND (pin 4) ────────────── Ground
   
   100nF capacitor between VCC and GND
```

Remember that while DebugWire provides powerful debugging capabilities with just one wire, it **temporarily disables normal ISP programming** until you explicitly disable the DebugWire mode.

## Program *blink* using AVR-GCC

I need to provide:
1. Setup requirements (hardware and software)
2. A simple blink.c program
3. Compilation steps using avr-gcc
4. How to generate the hex file
5. How to flash the program to the ATtiny13A
6. Fuse bit configuration if needed

The ATtiny13A is an 8-bit AVR microcontroller with 1KB flash, 64 bytes SRAM, and 64 bytes EEPROM. It runs at up to 20MHz with an external crystal or 9.6MHz with internal oscillator.

</details>

Here's a comprehensive guide to programming the **ATtiny13A** using avr-gcc and command-line tools:

## Prerequisites

### Hardware Requirements
- **ATtiny13A microcontroller**
- **ISP programmer** (USBasp, USBtinyISP, or Arduino as ISP)
- **Breadboard and jumper wires**
- **LED and resistor** (220Ω - 1kΩ)
- **Power supply** (3.3V or 5V)

### Software Requirements
- **avr-gcc** (AVR toolchain)
- **avrdude** (for flashing)
- **make** (optional but recommended)

## Simple Blink Program (examples/blink_avr)

Use *blink_avr*, as it doesn't depend on any *AVR_C* Library functions. Much of the *AVR_C* functionality is dependent on features not available on the ```ATtiny13A```.

```c
//  blink_avr - uses bit setting by registers instead of digitalWrite()
//  for smallest code size, set LIBRARY = no_lib in env.make 
//   Smallest code size allows you to use a scope to confirm delay 
//   is exactly 1 millisecondor other timing exercises.
//   For example: (when measured):
//   blink 2.0108s period while avr_blink 2.0022s period for a delay of 1000ms
//   or remove the delays and determine fastest blink is 2.02MHz w/ -Og -ggdb
//   or remove the delays and determine fastest blink is 2.68MHz w/ -Os -g

#include <avr/io.h>
#include <util/delay.h>
 
#define BLINK_DELAY_MS 1000
 
int main(void)
{
    /* set pin to output*/
    DDRB |= (_BV(PORTB5));

    while(1) 
    {
        /* turn led on and off */
        PINB |= (_BV(PORTB5));
        _delay_ms(BLINK_DELAY_MS);
        PINB |= (_BV(PORTB5));
        _delay_ms(BLINK_DELAY_MS);
    }
    return 0; 
}
```

## Compilation Steps

### Step 1: Confirm env.make
```bash
# ATtiny13A, be sure to set LIBRARY = no_lib as many AVR_C library functions are not compatible
MCU = attiny13a
SERIAL = /dev/ttyACM0
F_CPU = 1200000UL
USB_BAUD = 250000UL
SOFT_RESET = 0
LIBDIR = $(DEPTH)Library
LIBRARY = no_lib
PROGRAMMER_TYPE = atmelice_isp
PROGRAMMER_ARGS = -F -V -P usb -b 115200
TOOLCHAIN =
OS =
TC3_RESET = 0
SOFT_BAUD = 28800UL
```

### Step 2: Check compilation
```bash
make compile
```

### Step 3: Attach ATMEL ICE (or SNAP)

Connect your **ISP programmer** to the ATtiny13A:

| ISP Pin | ATtiny13A Pin | Physical Pin |
|---------|---------------|--------------|
| VCC     | VCC           | Pin 8        |
| GND     | GND           | Pin 4        |
| MISO    | PB0           | Pin 5        |
| MOSI    | PB1           | Pin 6        |
| SCK     | PB2           | Pin 7        |
| RESET   | PB5/RESET     | Pin 1        |

### Step 4: Check Program Size (Optional)
```bash
make size
```

### Step 5: Upload Program

```bash
make flash
```

## Fuse Configuration (Optional)

The **ATtiny13A** comes with default fuse settings for 1.2MHz internal oscillator. To change clock settings:

### Read Current Fuses
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

### Common Fuse Settings

**9.6MHz Internal Oscillator:**
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xFF:m
```

**4.8MHz Internal Oscillator:**
```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

⚠️ **Warning:** Be careful with fuse settings! Incorrect values can brick your chip.

## Troubleshooting

**"Device signature = 0x000000" error:**
- Check wiring connections
- Verify power supply
- Try slower programming speed: ```-B 10```

**"Initialization failed" error:**
- Ensure programmer drivers are installed
- Check USB connection
- Verify programmer type in avrdude command

**LED not blinking:**
- Verify LED polarity and resistor value
- Check if correct pin is used in code
- Ensure F_CPU matches actual clock frequency

## Next Steps

Once you have the basic blink working, you can:
- Experiment with different **I/O pins** (PB0-PB5)
- Use **timers** for more accurate delays
- Implement **PWM** for LED brightness control
- Add **button inputs** with interrupts
- Utilize **ADC** for analog readings
- Implement **power-saving modes**

### Alternative Programmer Types for Atmel-ICE
The Atmel-ICE supports multiple programming modes:
- **ISP mode**: ```-c atmelice_isp```
- **debugWIRE**: ```-c atmelice_dw```

## Microchip SNAP Programmer

### Basic Flash Command
```bash
avrdude -c snap_isp -p attiny13a -U flash:w:blink.hex:i
```

### With Port Specification
```bash
avrdude -c snap_isp -p attiny13a -P usb -U flash:w:blink.hex:i
```

### Connection Speed
Both programmers may benefit from specifying a bit clock rate, especially for targets with slow clocks:
```bash
# For Atmel-ICE
avrdude -c atmelice_isp -p attiny13a -B 10 -U flash:w:blink.hex:i

# For SNAP
avrdude -c snap_isp -p attiny13a -B 10 -U flash:w:blink.hex:i
```

The ```-B``` parameter sets the ISP clock period in microseconds.

### Voltage Settings
The **SNAP programmer doesn't provide target power**, so you must power the ATtiny13A externally. The Atmel-ICE can provide power, but it's often better to use external power.

## Troubleshooting Specific to These Programmers

### Atmel-ICE Issues
- **"No Atmel-ICE units found"**: Check USB drivers, may need to install **libusb** on Linux
- **Connection issues**: Try adding ```-B 10``` to slow down ISP clock
- **Permission errors on Linux**: Add udev rules or run with sudo

### SNAP Issues
- **"Cannot find SNAP"**: Update to latest AVRDUDE version
- **Power issues**: Remember SNAP doesn't supply power - **external power required**
- **Slower programming**: SNAP can be slower than other programmers; this is normal

### Linux USB Permissions
For both programmers on Linux, you may need to add udev rules:

Create ```/etc/udev/rules.d/99-atmel.rules```:
```bash
# Atmel-ICE
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2141", MODE="0666"

# Microchip SNAP
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2180", MODE="0666"
```

Then reload rules:
```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
```

Both the **Atmel-ICE** and **SNAP** are professional-grade programmers that work well with AVRDUDE once properly configured. The Atmel-ICE offers more features and debugging capabilities, while the SNAP is a more affordable option that handles basic ISP programming well.

## Understanding the Clock frequencies

The ATtiny13A indeed has an internal RC oscillator that can run at either 4.8MHz or 9.6MHz. However, there's also a clock divider (CLKDIV8) that is enabled by default from the factory, which divides the clock by 8. So:

- Default factory setting: 9.6MHz oscillator with CLKDIV8 enabled = 1.2MHz system clock
- The 1.2MHz I mentioned is the default system clock frequency after the divider
- The datasheet is talking about the oscillator frequency before division

So both are correct - the oscillator runs at 9.6MHz but the system clock is 1.2MHz by default due to the divider.

To run at 9.6MHz, you need to:
1. Keep the oscillator at 9.6MHz (which is already the default)
2. Disable the CLKDIV8 fuse

## ATtiny13A Clock System Explanation

The **ATtiny13A** has an internal RC oscillator that runs at either:
- **9.6MHz** (default oscillator setting)
- **4.8MHz** (alternative setting)

However, there's a crucial detail: the **CLKDIV8 fuse is programmed by default** from the factory, which divides the clock by 8. This means:

- **Default from factory**: 9.6MHz ÷ 8 = **1.2MHz system clock**
- This is why I mentioned 1.2MHz - it's the actual system clock frequency with default fuses

## Fuse Settings for Different Frequencies

### To Run at 9.6MHz System Clock

You need to **disable CLKDIV8** (unprogram the fuse bit):

```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x7A) breakdown:**
- Bits 7:6 = 01 (CKDIV8 unprogrammed - no clock division)
- Bits 5:4 = 11 (Start-up time)
- Bits 3:2 = 10 (Reserved)
- Bits 1:0 = 10 (9.6MHz internal oscillator)

### To Run at 4.8MHz System Clock

```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x79) breakdown:**
- Bits 7:6 = 01 (CKDIV8 unprogrammed)
- Bits 1:0 = 01 (4.8MHz internal oscillator)

### To Run at 1.2MHz System Clock (Factory Default)

```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x6A:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x6A) breakdown:**
- Bits 7:6 = 00 (CKDIV8 programmed - clock divided by 8)
- Bits 1:0 = 10 (9.6MHz ÷ 8 = 1.2MHz)

### Compile for 9.6MHz

Update the Makefile:
```makefile
F_CPU = 9600000UL  # 9.6MHz instead of 1200000UL
```

## Reading Current Fuse Settings

To check your current fuse configuration:

```bash
avrdude -c atmelice_isp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

**Default factory values:**
- Low Fuse: **0x6A**
- High Fuse: **0xFF**

## Complete Fuse Reference

| Clock Speed | Low Fuse | CLKDIV8 | Oscillator |
|-------------|----------|----------|------------|
| 9.6MHz      | 0x7A     | Disabled | 9.6MHz     |
| 4.8MHz      | 0x79     | Disabled | 4.8MHz     |
| 1.2MHz      | 0x6A     | Enabled  | 9.6MHz÷8   |
| 600kHz      | 0x69     | Enabled  | 4.8MHz÷8   |

## Important Notes

1. **F_CPU must match actual clock**: If you set fuses for 9.6MHz but compile with F_CPU=1200000UL, delays will be **8 times faster** than expected

2. **Power consumption**: Higher clock speeds consume more power

3. **Voltage requirements**: At higher frequencies, ensure adequate voltage (see datasheet for speed grades)

4. **After changing fuses**: The new clock speed takes effect immediately, so subsequent programming operations will use the new speed

The confusion often arises because Atmel/Microchip ships the chips with **CLKDIV8 enabled by default** for compatibility and lower power consumption, even though the oscillator itself runs at 9.6MHz.

# ATtiny13A
[ATtiny13A-Data-Sheet-DS40002307A](https://ww1.microchip.com/downloads/en/DeviceDoc/ATtiny13A-Data-Sheet-DS40002307A.pdf)
https://bloom.oscillate.io/docs/target/attiny13a
Creating a fully functional **ATtiny13** circuit requires several key components beyond just the microcontroller itself. Here's what you need for a complete schematic:
## Links to Projects
* [Enable PWM on an ATtiny by programming its registers](https://www.hackster.io/bearislive/enable-pwm-on-an-attiny-by-programming-its-registers-565948)
* [Programming an ATtiny13A in Assembly](https://www.hackster.io/gatoninja236/programming-an-attiny13a-in-assembly-30a529)
* [Programming the ATTINY13 \(Microcore\)](https://bryceautomation.com/index.php/2021/08/16/programming-the-attiny13-microcore/)
* [Various programs for attiny13a](https://github.com/hack-tramp/attiny13a)
* [Programming ATtiny13 with Arduino Uno to control a Servo Motor](https://circuitdigest.com/microcontroller-projects/programming-attiny13-with-arduino-uno-control-a-servo-motor)
* [ATtiny13A programming - Page 1](https://www.eevblog.com/forum/microcontrollers/attiny13a-programing/)
* [Stack Exchange: ATTiny13 -- avr-gcc Hello World uses over 100 bytes?](https://electronics.stackexchange.com/questions/2377/attiny13-avr-gcc-hello-world-uses-over-100-bytes)
* [Smart LED Prototypes](https://todbot.com/blog/2007/03/25/smart-led-prototypes/)
* [Stack Exchange: Missing crt* file](https://stackoverflow.com/questions/20356871/avr-gcc-destructive-optimizations)
* [benwattsjones/AVR-Microcontroller-Tutorial: A series of lessons on programming AVR MCUs using GCC-AVR on linux](https://github.com/benwattsjones/AVR-Microcontroller-Tutorial)
* [ATtiny13A Examples](https://github.com/casperbang/avr-attiny-tutorial?tab=readme-ov-file)
## **Basic Circuit Requirements**

The **ATtiny13 is a low-power CMOS 8-bit microcontroller** based on the AVR enhanced RISC architecture. To make it functional, you'll need:

### **Power Supply Components**
- **VCC**: Connect to pin 8 (supply voltage: 2.7V to 5.5V)
- **GND**: Connect to pin 4
- **Decoupling capacitor**: 100nF ceramic capacitor between VCC and GND, placed as close to the chip as possible

### **Programming Interface**
For In-System Programming (ISP), connect:
- **MISO** (PB0) - Pin 5
- **MOSI** (PB1) - Pin 6  
- **SCK** (PB2) - Pin 7
- **RESET** - Pin 1
- **VCC** and **GND** from programmer

### **Reset Circuit**
- **10kΩ pull-up resistor** from RESET (pin 1) to VCC
- Optional: Small capacitor (100nF) from RESET to GND for noise immunity
- Optional: Reset button between RESET and GND

### **Basic Schematic Layout**

```
                    ATtiny13
                   ┌─────────┐
    RESET/PB5 ──1─┤         ├─8── VCC
          PB3 ──2─┤         ├─7── PB2/SCK
          PB4 ──3─┤         ├─6── PB1/MOSI
          GND ──4─┤         ├─5── PB0/MISO
                   └─────────┘
```

### **Minimal Working Circuit**
1. Connect **VCC** (pin 8) to your power supply (2.7-5.5V)
2. Connect **GND** (pin 4) to ground
3. Add **100nF decoupling capacitor** between VCC and GND
4. Add **10kΩ resistor** between RESET (pin 1) and VCC
5. Connect ISP header for programming

The **ATtiny13 contains 1KB of Flash memory** for program storage and features **6 I/O pins** that can be used for various functions. This makes it ideal for simple embedded applications where space and power consumption are critical factors.

For more complex applications, you might want to add:
- External crystal oscillator (though the ATtiny13 has an internal 9.6MHz oscillator)
- Additional filtering capacitors
- Protection diodes on I/O pins
- LED indicators for debugging

This basic schematic will give you a fully functional ATtiny13 that can be programmed and used in your projects.

: [[PDF] doc2535.pdf - Microchip Technology](https://ww1.microchip.com/downloads/en/devicedoc/doc2535.pdf#:~:text=The%20ATtiny13,clock%20cycle%2C)
: [ATtiny13](https://vhfdesign.com/data/pdf/ATtiny13.pdf#:~:text=The%20ATtiny13,RISC%20architecture.)
: [ATtiny13](https://www.microchip.com/content/dam/mchp/documents/OTH/ProductDocuments/DataSheets/doc2535.pdf#:~:text=The%20ATtiny13,write/erase%20cycles.)
: [ATtiny13 8-bit AVR Microcontroller Pinout, Features &amp; Datasheet](https://components101.com/microcontrollers/attiny13-8-bit-avr-microcontroller#:~:text=ATtiny13%20is,I/O%20pins.)

## Adding capability for debugging
To use **DebugWire** debugging with the ATtiny13, you'll need to make specific hardware and software configurations. Here's what you need to do:

## **Hardware Requirements for DebugWire**

### **Modified Reset Pin Configuration**
- **Remove the 10kΩ pull-up resistor** from the RESET pin (pin 1)
- The RESET pin becomes a **bidirectional communication line** when DebugWire is enabled
- Keep the reset line as short as possible to minimize noise

### **Simplified Connection**
When using DebugWire, you only need:
- **RESET/dW** (pin 1) - Connected to debugger
- **VCC** (pin 8) - Power supply
- **GND** (pin 4) - Ground
- **100nF decoupling capacitor** between VCC and GND

### **Important Considerations**

1. **Fuse Configuration**
   - You must **enable the DWEN (DebugWire Enable) fuse bit**
   - Once enabled, the RESET pin loses its reset functionality and becomes a DebugWire interface
   - ISP programming is disabled when DebugWire is active

2. **Debugger Requirements**
   - Use a compatible debugger like **Atmel-ICE**, **JTAGICE mkII**, or **AVR Dragon**
   - The debugger must support DebugWire protocol

3. **Power Cycling**
   - After enabling DebugWire, you need to **power cycle** the target device
   - The debugger will then communicate through the single-wire interface

### **To Disable DebugWire**
If you need to return to normal ISP programming:
1. Use the debugger to **disable DebugWire** through the debugging software
2. Or perform a **high-voltage programming** sequence to clear the DWEN fuse
3. This restores the RESET pin functionality

### **Circuit Modification Summary**
```
   For DebugWire Mode:
   
   RESET/dW (pin 1) ──────── To Debugger (no pull-up)
   VCC (pin 8) ────────────── Power Supply
   GND (pin 4) ────────────── Ground
   
   100nF capacitor between VCC and GND
```

Remember that while DebugWire provides powerful debugging capabilities with just one wire, it **temporarily disables normal ISP programming** until you explicitly disable the DebugWire mode.

The user wants to program an ATtiny13A microcontroller using avr-gcc directly, without using Arduino or Microchip IDEs. They want detailed instructions and a simple blink.c example.

I need to provide:
1. Setup requirements (hardware and software)
2. A simple blink.c program
3. Compilation steps using avr-gcc
4. How to generate the hex file
5. How to flash the program to the ATtiny13A
6. Fuse bit configuration if needed

The ATtiny13A is an 8-bit AVR microcontroller with 1KB flash, 64 bytes SRAM, and 64 bytes EEPROM. It runs at up to 20MHz with an external crystal or 9.6MHz with internal oscillator.

</details>

Here's a comprehensive guide to programming the **ATtiny13A** using avr-gcc and command-line tools:

## Prerequisites

### Hardware Requirements
- **ATtiny13A microcontroller**
- **ISP programmer** (USBasp, USBtinyISP, or Arduino as ISP)
- **Breadboard and jumper wires**
- **LED and resistor** (220Ω - 1kΩ)
- **Power supply** (3.3V or 5V)

### Software Requirements
- **avr-gcc** (AVR toolchain)
- **avrdude** (for flashing)
- **make** (optional but recommended)

### Installing the AVR Toolchain

**On Linux (Ubuntu/Debian):**
```bash
sudo apt-get update
sudo apt-get install gcc-avr avr-libc avrdude
```

**On macOS:**
```bash
brew tap osx-cross/avr
brew install avr-gcc avrdude
```

**On Windows:**
Download and install WinAVR or use the AVR toolchain from Microchip (just the toolchain, not the IDE).

## Simple Blink Program

Create a file named ```blink.c```:

```c
#include <avr/io.h>
#include <util/delay.h>

#define LED_PIN PB4  // Pin 3 on ATtiny13A

int main(void) {
    // Set LED pin as output
    DDRB |= (1 << LED_PIN);
    
    while (1) {
        // Turn LED on
        PORTB |= (1 << LED_PIN);
        _delay_ms(500);
        
        // Turn LED off
        PORTB &= ~(1 << LED_PIN);
        _delay_ms(500);
    }
    
    return 0;
}
```

## Compilation Steps

### Step 1: Compile to Object File
```bash
avr-gcc -mmcu=attiny13a -DF_CPU=1200000UL -Os -c blink.c -o blink.o
```

**Parameters explained:**
- ```-mmcu=attiny13a```: Specifies the target microcontroller
- ```-DF_CPU=1200000UL```: Sets CPU frequency (1.2MHz default with internal oscillator)
- ```-Os```: Optimize for size
- ```-c```: Compile only, don't link
- ```-o```: Output file name

### Step 2: Link Object File
```bash
avr-gcc -mmcu=attiny13a -o blink.elf blink.o
```

### Step 3: Generate Intel HEX File
```bash
avr-objcopy -O ihex -R .eeprom blink.elf blink.hex
```

### Step 4: Check Program Size (Optional)
```bash
avr-size --format=avr --mcu=attiny13a blink.elf
```

## Using a Makefile (Recommended)

Create a ```Makefile``` to automate the build process:

```makefile
# Makefile for ATtiny13A
MCU = attiny13a
F_CPU = 1200000UL
TARGET = blink
SRC = blink.c
PROGRAMMER = usbasp

CC = avr-gcc
OBJCOPY = avr-objcopy
CFLAGS = -mmcu=$(MCU) -DF_CPU=$(F_CPU) -Os -Wall
OBJFLAGS = -O ihex -R .eeprom

all: $(TARGET).hex

$(TARGET).elf: $(SRC)
	$(CC) $(CFLAGS) -o $@ $^

$(TARGET).hex: $(TARGET).elf
	$(OBJCOPY) $(OBJFLAGS) $< $@

flash: $(TARGET).hex
	avrdude -c $(PROGRAMMER) -p $(MCU) -U flash:w:$(TARGET).hex:i

clean:
	rm -f $(TARGET).elf $(TARGET).hex

size: $(TARGET).elf
	avr-size --format=avr --mcu=$(MCU) $(TARGET).elf

.PHONY: all flash clean size
```

Now you can simply run:
```bash
make          # Build the hex file
make flash    # Flash to ATtiny13A
make clean    # Clean build files
make size     # Check program size
```

## Flashing the Program

### Hardware Connections

Connect your **ISP programmer** to the ATtiny13A:

| ISP Pin | ATtiny13A Pin | Physical Pin |
|---------|---------------|--------------|
| VCC     | VCC           | Pin 8        |
| GND     | GND           | Pin 4        |
| MISO    | PB0           | Pin 5        |
| MOSI    | PB1           | Pin 6        |
| SCK     | PB2           | Pin 7        |
| RESET   | PB5/RESET     | Pin 1        |

### Flash Command
```bash
avrdude -c usbasp -p attiny13a -U flash:w:blink.hex:i
```

**Common programmer types:**
- ```-c usbasp```: For USBasp programmer
- ```-c usbtiny```: For USBtinyISP
- ```-c arduino```: For Arduino as ISP

## Fuse Configuration (Optional)

The **ATtiny13A** comes with default fuse settings for 1.2MHz internal oscillator. To change clock settings:

### Read Current Fuses
```bash
avrdude -c usbasp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

### Common Fuse Settings

**9.6MHz Internal Oscillator:**
```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xFF:m
```

**4.8MHz Internal Oscillator:**
```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

⚠️ **Warning:** Be careful with fuse settings! Incorrect values can brick your chip.

## Troubleshooting

**"Device signature = 0x000000" error:**
- Check wiring connections
- Verify power supply
- Try slower programming speed: ```-B 10```

**"Initialization failed" error:**
- Ensure programmer drivers are installed
- Check USB connection
- Verify programmer type in avrdude command

**LED not blinking:**
- Verify LED polarity and resistor value
- Check if correct pin is used in code
- Ensure F_CPU matches actual clock frequency

## Next Steps

Once you have the basic blink working, you can:
- Experiment with different **I/O pins** (PB0-PB5)
- Use **timers** for more accurate delays
- Implement **PWM** for LED brightness control
- Add **button inputs** with interrupts
- Utilize **ADC** for analog readings
- Implement **power-saving modes**

This setup gives you complete control over the ATtiny13A without relying on any IDE, using only command-line tools and a text editor of your choice.

## Directions above, however, added ATMEL ICE and Microchip SNAP
<details><summary>Thinking</summary>

The user is asking about specific AVRDUDE commands for two programmers: ATMEL ICE and Microchip SNAP. I need to provide the correct programmer identifiers for avrdude and any specific considerations for these programmers.

For ATMEL ICE, the avrdude programmer type is typically "atmelice" or "atmelice_isp" for ISP programming.

For Microchip SNAP, it's a newer programmer and the support in avrdude might be "snap_isp" or similar.

I should also mention any specific requirements or limitations for these programmers.

</details>

Here are the AVRDUDE commands for programming the **ATtiny13A** with the **Atmel-ICE** and **Microchip SNAP** programmers:

## Atmel-ICE Programmer

### Basic Flash Command
```bash
avrdude -c atmelice_isp -p attiny13a -U flash:w:blink.hex:i
```

### With Port Specification (if needed)
```bash
avrdude -c atmelice_isp -p attiny13a -P usb -U flash:w:blink.hex:i
```

### Alternative Programmer Types for Atmel-ICE
The Atmel-ICE supports multiple programming modes:
- **ISP mode**: ```-c atmelice_isp```
- **PDI mode**: ```-c atmelice_pdi``` (not for ATtiny13A)
- **JTAG mode**: ```-c atmelice``` (not for ATtiny13A)
- **debugWIRE**: ```-c atmelice_dw```

## Microchip SNAP Programmer

### Basic Flash Command
```bash
avrdude -c snap_isp -p attiny13a -U flash:w:blink.hex:i
```

### With Port Specification
```bash
avrdude -c snap_isp -p attiny13a -P usb -U flash:w:blink.hex:i
```

## Important Considerations

### AVRDUDE Version Requirements
- **Atmel-ICE**: Requires AVRDUDE version **6.3 or later**
- **Microchip SNAP**: Requires AVRDUDE version **6.4 or later** (better support in **7.0+**)

Check your version:
```bash
avrdude -v
```

### Connection Speed
Both programmers may benefit from specifying a bit clock rate, especially for targets with slow clocks:
```bash
# For Atmel-ICE
avrdude -c atmelice_isp -p attiny13a -B 10 -U flash:w:blink.hex:i

# For SNAP
avrdude -c snap_isp -p attiny13a -B 10 -U flash:w:blink.hex:i
```

The ```-B``` parameter sets the ISP clock period in microseconds.

### Voltage Settings
The **SNAP programmer doesn't provide target power**, so you must power the ATtiny13A externally. The Atmel-ICE can provide power, but it's often better to use external power.

## Updated Makefile for Multiple Programmers

Here's an updated Makefile that allows you to specify the programmer:

```makefile
# Makefile for ATtiny13A with programmer selection
MCU = attiny13a
F_CPU = 1200000UL
TARGET = blink
SRC = blink.c

# Default programmer (change as needed)
PROGRAMMER ?= usbasp
# PROGRAMMER ?= atmelice_isp
# PROGRAMMER ?= snap_isp

# Programming options
AVRDUDE_FLAGS = -p $(MCU) -c $(PROGRAMMER)

# Add port for certain programmers
ifeq ($(PROGRAMMER),atmelice_isp)
    AVRDUDE_FLAGS += -P usb
endif
ifeq ($(PROGRAMMER),snap_isp)
    AVRDUDE_FLAGS += -P usb -B 10
endif

CC = avr-gcc
OBJCOPY = avr-objcopy
AVRDUDE = avrdude
CFLAGS = -mmcu=$(MCU) -DF_CPU=$(F_CPU) -Os -Wall
OBJFLAGS = -O ihex -R .eeprom

all: $(TARGET).hex

$(TARGET).elf: $(SRC)
	$(CC) $(CFLAGS) -o $@ $^

$(TARGET).hex: $(TARGET).elf
	$(OBJCOPY) $(OBJFLAGS) $< $@

flash: $(TARGET).hex
	$(AVRDUDE) $(AVRDUDE_FLAGS) -U flash:w:$(TARGET).hex:i

# Verify flash
verify: $(TARGET).hex
	$(AVRDUDE) $(AVRDUDE_FLAGS) -U flash:v:$(TARGET).hex:i

# Read fuses
read_fuses:
	$(AVRDUDE) $(AVRDUDE_FLAGS) -U lfuse:r:-:h -U hfuse:r:-:h

clean:
	rm -f $(TARGET).elf $(TARGET).hex

.PHONY: all flash verify read_fuses clean
```

### Using the Makefile with Different Programmers
```bash
# Using default programmer
make flash

# Using Atmel-ICE
make flash PROGRAMMER=atmelice_isp

# Using SNAP
make flash PROGRAMMER=snap_isp
```

## Troubleshooting Specific to These Programmers

### Atmel-ICE Issues
- **"No Atmel-ICE units found"**: Check USB drivers, may need to install **libusb** on Linux
- **Connection issues**: Try adding ```-B 10``` to slow down ISP clock
- **Permission errors on Linux**: Add udev rules or run with sudo

### SNAP Issues
- **"Cannot find SNAP"**: Update to latest AVRDUDE version
- **Power issues**: Remember SNAP doesn't supply power - **external power required**
- **Slower programming**: SNAP can be slower than other programmers; this is normal

### Linux USB Permissions
For both programmers on Linux, you may need to add udev rules:

Create ```/etc/udev/rules.d/99-atmel.rules```:
```bash
# Atmel-ICE
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2141", MODE="0666"

# Microchip SNAP
SUBSYSTEM=="usb", ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="2180", MODE="0666"
```

Then reload rules:
```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
```

Both the **Atmel-ICE** and **SNAP** are professional-grade programmers that work well with AVRDUDE once properly configured. The Atmel-ICE offers more features and debugging capabilities, while the SNAP is a more affordable option that handles basic ISP programming well.

## Understanding the Clock frequencies
<details><summary>Thinking</summary>

The user is correct to point out this discrepancy. Let me check what I know about the ATtiny13A's clock system.

The ATtiny13A indeed has an internal RC oscillator that can run at either 4.8MHz or 9.6MHz. However, there's also a clock divider (CLKDIV8) that is enabled by default from the factory, which divides the clock by 8. So:

- Default factory setting: 9.6MHz oscillator with CLKDIV8 enabled = 1.2MHz system clock
- The 1.2MHz I mentioned is the default system clock frequency after the divider
- The datasheet is talking about the oscillator frequency before division

So both are correct - the oscillator runs at 9.6MHz but the system clock is 1.2MHz by default due to the divider.

To run at 9.6MHz, you need to:
1. Keep the oscillator at 9.6MHz (which is already the default)
2. Disable the CLKDIV8 fuse

Let me provide the correct fuse settings and explanation.

</details>

You're absolutely correct! Let me clarify the **clock system** of the ATtiny13A:

## ATtiny13A Clock System Explanation

The **ATtiny13A** has an internal RC oscillator that runs at either:
- **9.6MHz** (default oscillator setting)
- **4.8MHz** (alternative setting)

However, there's a crucial detail: the **CLKDIV8 fuse is programmed by default** from the factory, which divides the clock by 8. This means:

- **Default from factory**: 9.6MHz ÷ 8 = **1.2MHz system clock**
- This is why I mentioned 1.2MHz - it's the actual system clock frequency with default fuses

## Fuse Settings for Different Frequencies

### To Run at 9.6MHz System Clock

You need to **disable CLKDIV8** (unprogram the fuse bit):

```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x7A:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x7A) breakdown:**
- Bits 7:6 = 01 (CKDIV8 unprogrammed - no clock division)
- Bits 5:4 = 11 (Start-up time)
- Bits 3:2 = 10 (Reserved)
- Bits 1:0 = 10 (9.6MHz internal oscillator)

### To Run at 4.8MHz System Clock

```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x79:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x79) breakdown:**
- Bits 7:6 = 01 (CKDIV8 unprogrammed)
- Bits 1:0 = 01 (4.8MHz internal oscillator)

### To Run at 1.2MHz System Clock (Factory Default)

```bash
avrdude -c usbasp -p attiny13a -U lfuse:w:0x6A:m -U hfuse:w:0xFF:m
```

**Low Fuse (0x6A) breakdown:**
- Bits 7:6 = 00 (CKDIV8 programmed - clock divided by 8)
- Bits 1:0 = 10 (9.6MHz ÷ 8 = 1.2MHz)

## Updated Blink Code for 9.6MHz

When running at **9.6MHz**, update your code's F_CPU definition:

```c
#include <avr/io.h>
#include <util/delay.h>

#define LED_PIN PB4  // Pin 3 on ATtiny13A

int main(void) {
    // Set LED pin as output
    DDRB |= (1 << LED_PIN);
    
    while (1) {
        // Turn LED on
        PORTB |= (1 << LED_PIN);
        _delay_ms(500);
        
        // Turn LED off
        PORTB &= ~(1 << LED_PIN);
        _delay_ms(500);
    }
    
    return 0;
}
```

### Compile for 9.6MHz
```bash
avr-gcc -mmcu=attiny13a -DF_CPU=9600000UL -Os -c blink.c -o blink.o
```

Or update the Makefile:
```makefile
F_CPU = 9600000UL  # 9.6MHz instead of 1200000UL
```

## Reading Current Fuse Settings

To check your current fuse configuration:

```bash
avrdude -c usbasp -p attiny13a -U lfuse:r:-:h -U hfuse:r:-:h
```

**Default factory values:**
- Low Fuse: **0x6A**
- High Fuse: **0xFF**

## Complete Fuse Reference

| Clock Speed | Low Fuse | CLKDIV8 | Oscillator |
|-------------|----------|----------|------------|
| 9.6MHz      | 0x7A     | Disabled | 9.6MHz     |
| 4.8MHz      | 0x79     | Disabled | 4.8MHz     |
| 1.2MHz      | 0x6A     | Enabled  | 9.6MHz÷8   |
| 600kHz      | 0x69     | Enabled  | 4.8MHz÷8   |

## Important Notes

1. **F_CPU must match actual clock**: If you set fuses for 9.6MHz but compile with F_CPU=1200000UL, delays will be **8 times faster** than expected

2. **Power consumption**: Higher clock speeds consume more power

3. **Voltage requirements**: At higher frequencies, ensure adequate voltage (see datasheet for speed grades)

4. **After changing fuses**: The new clock speed takes effect immediately, so subsequent programming operations will use the new speed

The confusion often arises because Atmel/Microchip ships the chips with **CLKDIV8 enabled by default** for compatibility and lower power consumption, even though the oscillator itself runs at 9.6MHz.

